<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ãƒ€ãƒ–ã£ã¦ã‚‹ï¼Ÿï¼Ÿ</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body { touch-action: manipulation; }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px) rotate(-5deg); }
            75% { transform: translateX(5px) rotate(5deg); }
        }
        .animate-shake {
            animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
        }
        .animate-pop {
            animation: pop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes pop {
            0% { transform: scale(0); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        /* Penalty text animation */
        @keyframes float-up {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-30px); opacity: 0; }
        }
        .animate-float-up {
            animation: float-up 0.8s ease-out forwards;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        // --- Icons (SVG) ---
        const IconClock = ({ size = 24, className }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
        );
        const IconTrophy = ({ size = 24, className, fill="none" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill={fill} stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"></path><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"></path><path d="M4 22h16"></path><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"></path><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"></path><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"></path></svg>
        );
        const IconInfinity = ({ size = 24, className }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M12 12c-2-2.67-4-4-6-4a4 4 0 1 0 0 8c2 0 4-1.33 6-4Zm0 0c2 2.67 4 4 6 4a4 4 0 1 0 0-8c-2 0-4 1.33-6 4Z"></path></svg>
        );
        const IconStar = ({ size = 24, className, fill="none" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill={fill} stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>
        );
        const IconRotateCcw = ({ size = 24, className }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>
        );
        const IconHome = ({ size = 24, className }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></svg>
        );
        const IconCrown = ({ size = 24, className, fill="none" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill={fill} stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m2 4 3 12h14l3-12-6 7-4-7-4 7-6-7zm3 16h14"></path></svg>
        );

        // --- Data ---
        const SAFE_EMOJIS = [
            "ğŸ¶","ğŸ±","ğŸ­","ğŸ¹","ğŸ°","ğŸ»","ğŸ¼","ğŸ¨","ğŸ¯","ğŸ¦","ğŸ®","ğŸ·","ğŸ¸","ğŸµ","ğŸ”",
            "ğŸ§","ğŸ¦","ğŸ¤","ğŸ¦†","ğŸ¦‰","ğŸ¦„","ğŸ","ğŸ›","ğŸ¦‹","ğŸ","ğŸŒ","ğŸ¢","ğŸ","ğŸ¦","ğŸ¦–",
            "ğŸ™","ğŸ¦‘","ğŸ¦€","ğŸ ","ğŸ¬","ğŸ³","ğŸ¦ˆ","ğŸŠ","ğŸ¦“","ğŸ¦","ğŸ˜","ğŸ¦›","ğŸ¦’","ğŸ¦˜","ğŸ",
            "ğŸŠ","ğŸ‹","ğŸŒ","ğŸ‰","ğŸ‡","ğŸ“","ğŸ’","ğŸ‘","ğŸ","ğŸ¥","ğŸ…","ğŸ¥‘","ğŸ¥¦","ğŸŒ½","ğŸ¥•",
            "âš½","ğŸ€","ğŸˆ","âš¾","ğŸ¾","ğŸ","ğŸ‰","ğŸ±","ğŸš—","ğŸš•","ğŸš™","ğŸšŒ","ğŸš“","ğŸš‘","ğŸš’",
            "ğŸš€","ğŸš","ğŸš‚","âš“","âŒš","â°","ğŸˆ","ğŸ‰","ğŸ","ğŸ‘‘","ğŸ’","ğŸ””","ğŸµ","ğŸ“·","ğŸ“š",
            "ğŸ”","ğŸŸ","ğŸ•","ğŸŒ­","ğŸ¥ª","ğŸŒ®","ğŸ¦","ğŸ©","ğŸª","ğŸ‚","ğŸ¬","ğŸ­","ğŸ«","ğŸ¿","ğŸ§‚"
        ];

        const MODES = { MENU: 'menu', SETTINGS: 'settings', DIFFICULTY: 'difficulty', GAME: 'game', RESULT: 'result' };

        // Updated Game Types based on request
        const GAME_TYPES = {
            SCORE_ATTACK: { id: 'scoreAttack', label: 'ã‚¹ã‚³ã‚¢ã‚¢ã‚¿ãƒƒã‚¯', sub: 'ã˜ã‹ã‚“ãªã„ã« ãŸãã•ã‚“ã¿ã¤ã‘ã‚ˆã†', icon: <IconClock size={24} />, unit: 'ã³ã‚‡ã†' },
            TIME_ATTACK: { id: 'timeAttack', label: 'ã‚¿ã‚¤ãƒ ã‚¢ã‚¿ãƒƒã‚¯', sub: 'ãã‚ã‚‰ã‚ŒãŸæ•°ã‚’ ã¯ã‚„ãã¿ã¤ã‘ã‚ˆã†', icon: <IconTrophy size={24} />, unit: 'ã‚‚ã‚“' },
            PRACTICE: { id: 'practice', label: 'ã‚Œã‚“ã—ã‚…ã†', sub: 'ã˜ã‚†ã†ã«ã‚ãã¶', icon: <IconInfinity size={24} />, unit: '' },
        };

        // Settings Options
        const SETTINGS_OPTIONS = {
            scoreAttack: [
                { value: 30, label: '30ã³ã‚‡ã†' },
                { value: 60, label: '1ã·ã‚“' },
                { value: 180, label: '3ãµã‚“' },
                { value: 300, label: '5ãµã‚“' },
            ],
            timeAttack: [
                { value: 10, label: '10ã‚‚ã‚“' },
                { value: 20, label: '20ã‚‚ã‚“' },
                { value: 30, label: '30ã‚‚ã‚“' },
                { value: 50, label: '50ã‚‚ã‚“' },
            ],
        };

        const DIFFICULTIES = {
            VERY_EASY: { id: 'very_easy', label: 'ã™ã”ãã‹ã‚“ãŸã‚“', n: 2, symbols: 3, color: 'bg-teal-100 text-teal-700 border-teal-300' },
            EASY: { id: 'easy', label: 'ã‹ã‚“ãŸã‚“', n: 3, symbols: 4, color: 'bg-green-100 text-green-700 border-green-300' },
            NORMAL: { id: 'normal', label: 'ãµã¤ã†', n: 5, symbols: 6, color: 'bg-blue-100 text-blue-700 border-blue-300' },
            HARD: { id: 'hard', label: 'ã‚€ãšã‹ã—ã„', n: 7, symbols: 8, color: 'bg-red-100 text-red-700 border-red-300' },
        };

        // --- Game Logic ---
        const generateDeck = (n, emojiList) => {
            const deck = [];
            const numSymbols = n * n + n + 1;
            const symbols = emojiList.slice(0, numSymbols);
            if (symbols.length < numSymbols) return [];

            const card1 = [];
            for (let i = 0; i <= n; i++) card1.push(symbols[i]);
            deck.push(card1);

            for (let j = 0; j < n; j++) {
                const card = [];
                card.push(symbols[0]);
                for (let i = 0; i < n; i++) card.push(symbols[n + 1 + j * n + i]);
                deck.push(card);
            }

            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    const card = [];
                    card.push(symbols[i + 1]);
                    for (let k = 0; k < n; k++) {
                        const val = n + 1 + k * n + ((j + i * k) % n);
                        card.push(symbols[val]);
                    }
                    deck.push(card);
                }
            }
            return deck;
        };

        const playSound = (type) => {
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!AudioContext) return;
                const ctx = new AudioContext();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);

                if (type === 'correct') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(587.33, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(880, ctx.currentTime + 0.1);
                    gain.gain.setValueAtTime(0.3, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                    osc.start(); osc.stop(ctx.currentTime + 0.3);
                } else if (type === 'wrong') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(150, ctx.currentTime);
                    gain.gain.setValueAtTime(0.3, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                    osc.start(); osc.stop(ctx.currentTime + 0.3);
                } else if (type === 'win') {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(523.25, ctx.currentTime);
                    osc.frequency.setValueAtTime(659.25, ctx.currentTime + 0.1);
                    osc.frequency.setValueAtTime(783.99, ctx.currentTime + 0.2);
                    osc.frequency.setValueAtTime(1046.50, ctx.currentTime + 0.3);
                    gain.gain.setValueAtTime(0.3, ctx.currentTime);
                    gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 1.0);
                    osc.start(); osc.stop(ctx.currentTime + 1.0);
                }
            } catch (e) {}
        };

        // --- Background Animation Component ---
        const BackgroundAnimation = () => {
            const [items] = useState(() => {
                const arr = [];
                for (let i = 0; i < 25; i++) {
                    arr.push({
                        id: i,
                        symbol: SAFE_EMOJIS[Math.floor(Math.random() * SAFE_EMOJIS.length)],
                        size: 40 + Math.random() * 80,
                        x: Math.random() * window.innerWidth,
                        y: Math.random() * window.innerHeight,
                        vx: (Math.random() - 0.5) * 1.5,
                        vy: (Math.random() - 0.5) * 1.5,
                        rotation: Math.random() * 360,
                        rotSpeed: (Math.random() - 0.5) * 1
                    });
                }
                return arr;
            });
            
            const refs = useRef([]);
            const stateRef = useRef(items.map(i => ({...i})));

            useEffect(() => {
                let frameId;
                const update = () => {
                    const w = window.innerWidth;
                    const h = window.innerHeight;
                    
                    stateRef.current.forEach((item, i) => {
                        const el = refs.current[i];
                        if (!el) return;
                        
                        item.x += item.vx;
                        item.y += item.vy;
                        item.rotation += item.rotSpeed;
                        
                        if (item.x < -100) item.x = w + 100;
                        if (item.x > w + 100) item.x = -100;
                        if (item.y < -100) item.y = h + 100;
                        if (item.y > h + 100) item.y = -100;

                        el.style.transform = `translate(${item.x}px, ${item.y}px) rotate(${item.rotation}deg)`;
                    });
                    frameId = requestAnimationFrame(update);
                };
                update();
                return () => cancelAnimationFrame(frameId);
            }, []);

            return (
                <div className="fixed inset-0 overflow-hidden -z-1 pointer-events-none opacity-20">
                    {items.map((item, i) => (
                        <div 
                            key={item.id} 
                            ref={el => refs.current[i] = el}
                            className="absolute top-0 left-0"
                            style={{ fontSize: item.size }}
                        >
                            {item.symbol}
                        </div>
                    ))}
                </div>
            );
        };

        // --- Card Component ---
        const Card = ({ symbols, onSymbolClick, disabled, isWrong }) => {
            const containerRef = useRef(null);
            const itemsRef = useRef([]);
            const itemElementsRef = useRef([]);
            const containerRadius = 110; 

            useEffect(() => {
                const sizeMap = {
                    1: { class: 'text-3xl sm:text-4xl', px: 35 },
                    2: { class: 'text-4xl sm:text-5xl', px: 45 },
                    3: { class: 'text-5xl sm:text-6xl', px: 55 },
                    4: { class: 'text-6xl sm:text-7xl', px: 70 },
                };

                itemsRef.current = symbols.map((symbol, index) => {
                    const sizeLevel = Math.floor(Math.random() * 4) + 1;
                    const sizeData = sizeMap[sizeLevel];
                    const itemRadius = sizeData.px / 2;

                    const maxR = containerRadius - itemRadius - 10;
                    const r = Math.sqrt(Math.random()) * maxR;
                    const theta = Math.random() * 2 * Math.PI;
                    const x = r * Math.cos(theta);
                    const y = r * Math.sin(theta);

                    const speed = 0.3 + Math.random() * 0.4;
                    const moveAngle = Math.random() * 2 * Math.PI;

                    return {
                        symbol, id: `${symbol}-${index}`, sizeClass: sizeData.class, radius: itemRadius,
                        x, y, vx: Math.cos(moveAngle) * speed, vy: Math.sin(moveAngle) * speed,
                        rotation: Math.random() * 360, rotationSpeed: (Math.random() - 0.5) * 0.4
                    };
                });
            }, [symbols]);

            useEffect(() => {
                let animationFrameId;
                const update = () => {
                    itemsRef.current.forEach((item, index) => {
                        const el = itemElementsRef.current[index];
                        if (!el) return;

                        item.x += item.vx;
                        item.y += item.vy;
                        item.rotation += item.rotationSpeed;

                        const dist = Math.sqrt(item.x * item.x + item.y * item.y);
                        const limit = containerRadius - item.radius;

                        if (dist > limit) {
                            const nx = item.x / dist;
                            const ny = item.y / dist;
                            const dot = item.vx * nx + item.vy * ny;
                            if (dot > 0) {
                                item.vx = item.vx - 2 * dot * nx;
                                item.vy = item.vy - 2 * dot * ny;
                                item.vx += (Math.random() - 0.5) * 0.1;
                                item.vy += (Math.random() - 0.5) * 0.1;
                            }
                            item.x = nx * limit;
                            item.y = ny * limit;
                        }

                        el.style.transform = `translate(${item.x}px, ${item.y}px) rotate(${item.rotation}deg)`;
                    });
                    animationFrameId = requestAnimationFrame(update);
                };
                update();
                return () => cancelAnimationFrame(animationFrameId);
            }, [symbols]);

            return (
                <div 
                    ref={containerRef} 
                    className={`relative bg-white rounded-full shadow-xl border-8 border-yellow-400 w-64 h-64 sm:w-80 sm:h-80 flex items-center justify-center transition-transform duration-200 overflow-hidden ${isWrong ? 'animate-shake border-red-400' : ''}`}
                >
                    {itemsRef.current.map((item, index) => (
                        <div key={item.id} ref={el => itemElementsRef.current[index] = el} className="absolute flex items-center justify-center will-change-transform">
                            <button onClick={() => !disabled && onSymbolClick(item.symbol)} disabled={disabled} className={`${item.sizeClass} leading-none select-none hover:scale-125 active:scale-95 transition-transform cursor-pointer filter drop-shadow-sm`}>{item.symbol}</button>
                        </div>
                    ))}
                </div>
            );
        };

        // --- Main App ---
        const App = () => {
            const [mode, setMode] = useState(MODES.MENU);
            const [gameType, setGameType] = useState(null);
            const [gameSetting, setGameSetting] = useState(null); // Time or Count
            const [difficulty, setDifficulty] = useState(null);
            const [score, setScore] = useState(0);
            const [timeLeft, setTimeLeft] = useState(0);
            const [elapsedTime, setElapsedTime] = useState(0);
            const [cards, setCards] = useState({ left: [], right: [] });
            const [deck, setDeck] = useState([]);
            const [isWrong, setIsWrong] = useState(false);
            const [matchFound, setMatchFound] = useState(null);
            const [penaltyMessage, setPenaltyMessage] = useState(null);
            const timerRef = useRef(null);
            const startTimeRef = useRef(null);

            // Records State
            const [highScores, setHighScores] = useState({});
            const [isNewRecord, setIsNewRecord] = useState(false);

            useEffect(() => {
                try {
                    const saved = localStorage.getItem('dobble_scores_v2');
                    if (saved) setHighScores(JSON.parse(saved));
                } catch(e) {}
            }, []);

            const formatTime = (seconds) => {
                const m = Math.floor(seconds / 60);
                const s = seconds % 60;
                return `${m}:${s.toString().padStart(2, '0')}`;
            };

            const selectGameType = (type) => { 
                setGameType(type);
                if (type.id === 'practice') {
                    setGameSetting(null);
                    setMode(MODES.DIFFICULTY);
                } else {
                    setMode(MODES.SETTINGS);
                }
            };

            const selectSetting = (value) => {
                setGameSetting(value);
                setMode(MODES.DIFFICULTY);
            };

            const selectDifficulty = (diff) => { 
                setDifficulty(diff); 
                startGame(gameType, gameSetting, diff); 
            };

            const startGame = (type, setting, diff) => {
                setScore(0); setElapsedTime(0); setIsWrong(false); setMatchFound(null); setIsNewRecord(false); setPenaltyMessage(null);
                const shuffledEmojis = [...SAFE_EMOJIS].sort(() => 0.5 - Math.random());
                const fullDeck = generateDeck(diff.n, shuffledEmojis);
                if (fullDeck.length === 0) { alert("Error"); setMode(MODES.MENU); return; }
                const shuffledDeck = fullDeck.sort(() => 0.5 - Math.random());
                setDeck(shuffledDeck);
                setCards({ left: shuffledDeck[0], right: shuffledDeck[1] });
                
                if (type.id === GAME_TYPES.SCORE_ATTACK.id) {
                    setTimeLeft(setting); // Set duration
                } else {
                    setTimeLeft(0);
                }
                
                startTimeRef.current = Date.now();
                setMode(MODES.GAME);
            };

            const endGame = useCallback(() => {
                if (timerRef.current) clearInterval(timerRef.current);
                playSound('win');
                setMode(MODES.RESULT);
            }, []);

            // Check for High Score
            useEffect(() => {
                if (mode === MODES.RESULT && gameType.id !== 'practice') {
                    const key = `${gameType.id}_${difficulty.id}_${gameSetting}`;
                    const currentRecord = highScores[key];
                    let isNew = false;
                    let newScores = { ...highScores };

                    if (gameType.id === 'scoreAttack') {
                        const bestScore = currentRecord ? currentRecord.value : 0;
                        if (score > bestScore) {
                            isNew = true;
                            newScores[key] = { value: score };
                        }
                    } else if (gameType.id === 'timeAttack') {
                        if (score >= gameSetting) {
                            const bestTime = currentRecord ? currentRecord.value : Infinity;
                            if (elapsedTime < bestTime) {
                                isNew = true;
                                newScores[key] = { value: elapsedTime };
                            }
                        }
                    }

                    if (isNew) {
                        setHighScores(newScores);
                        localStorage.setItem('dobble_scores_v2', JSON.stringify(newScores));
                        setIsNewRecord(true);
                        playSound('correct'); 
                    }
                }
            }, [mode, score, elapsedTime, gameType, difficulty, gameSetting, highScores]);

            useEffect(() => {
                if (mode === MODES.GAME) {
                    timerRef.current = setInterval(() => {
                        const now = Date.now();
                        const elapsed = Math.floor((now - startTimeRef.current) / 1000);
                        setElapsedTime(elapsed);
                        
                        if (gameType.id === GAME_TYPES.SCORE_ATTACK.id) {
                            const remaining = gameSetting - elapsed;
                            setTimeLeft(remaining);
                            if (remaining <= 0) endGame();
                        }
                    }, 100);
                }
                return () => clearInterval(timerRef.current);
            }, [mode, gameType, gameSetting, endGame]);

            const handleSymbolClick = (symbol) => {
                const isMatch = cards.left.includes(symbol) && cards.right.includes(symbol);
                if (isMatch) {
                    playSound('correct');
                    setMatchFound(symbol);
                    setTimeout(() => {
                        setScore(prev => prev + 1);
                        setMatchFound(null);
                        nextRound();
                    }, 200);
                } else {
                    playSound('wrong');
                    setIsWrong(true);
                    setTimeout(() => setIsWrong(false), 500);

                    // PENALTY LOGIC
                    if (gameType.id === GAME_TYPES.SCORE_ATTACK.id) {
                         setScore(prev => Math.max(0, prev - 1));
                         setPenaltyMessage("-1");
                         setTimeout(() => setPenaltyMessage(null), 800);
                    } else if (gameType.id === GAME_TYPES.TIME_ATTACK.id) {
                        startTimeRef.current -= 10000; // Add 10 seconds penalty
                        setPenaltyMessage("+10ç§’");
                        setTimeout(() => setPenaltyMessage(null), 800);
                    }
                }
            };

            const nextRound = () => {
                // Check win condition for Time Attack (fixed number)
                if (gameType.id === GAME_TYPES.TIME_ATTACK.id && score + 1 >= gameSetting) { 
                    endGame(); 
                    return; 
                }
                
                const idx1 = Math.floor(Math.random() * deck.length);
                let idx2 = Math.floor(Math.random() * deck.length);
                while (idx1 === idx2) idx2 = Math.floor(Math.random() * deck.length);
                setCards({ left: deck[idx1], right: deck[idx2] });
            };

            const getRecordDisplay = () => {
                if (!gameType || !difficulty || gameType.id === 'practice') return null;
                const key = `${gameType.id}_${difficulty.id}_${gameSetting}`;
                const record = highScores[key];
                if (!record) return "ã¾ã è¨˜éŒ²ãªã—";
                if (gameType.id === 'scoreAttack') return `${record.value}ã“`;
                if (gameType.id === 'timeAttack') return formatTime(record.value);
                return null;
            };

            // Render Views
            if (mode === MODES.MENU) {
                return (
                    <div className="min-h-screen bg-indigo-50 flex flex-col items-center justify-center p-4 font-sans text-slate-800 relative z-0">
                        <BackgroundAnimation />
                        <div className="relative z-10 w-full flex flex-col items-center">
                            <h1 className="text-6xl sm:text-7xl font-black text-indigo-600 mb-2 tracking-tighter drop-shadow-sm text-center bg-white/80 p-4 rounded-xl backdrop-blur-sm shadow-sm">ãƒ€ãƒ–ã£ã¦ã‚‹ï¼Ÿï¼Ÿ</h1>
                            <p className="text-xl sm:text-2xl text-indigo-500 mb-10 font-bold text-center bg-white/80 p-2 rounded-lg backdrop-blur-sm">ãŠãªã˜ãƒãƒ¼ã‚¯ã‚’ã•ãŒã›ï¼</p>
                            <div className="grid gap-4 w-full max-w-md px-4">
                                {Object.values(GAME_TYPES).map((type) => (
                                    <button key={type.id} onClick={() => selectGameType(type)} className="group relative overflow-hidden bg-white/90 hover:bg-indigo-500 border-b-4 border-indigo-200 hover:border-indigo-700 p-6 rounded-2xl shadow-lg transition-all duration-200 flex items-center text-left backdrop-blur-sm">
                                        <div className="bg-indigo-100 p-3 rounded-full mr-4 text-indigo-600 group-hover:bg-white group-hover:text-indigo-600 transition-colors">{type.icon}</div>
                                        <div><div className="text-2xl font-black text-slate-700 group-hover:text-white transition-colors">{type.label}</div><div className="text-sm text-slate-500 group-hover:text-indigo-100 transition-colors font-bold">{type.sub}</div></div>
                                    </button>
                                ))}
                            </div>
                        </div>
                    </div>
                );
            }

            if (mode === MODES.SETTINGS) {
                return (
                    <div className="min-h-screen bg-indigo-50 flex flex-col items-center justify-center p-4 font-sans relative z-0">
                        <BackgroundAnimation />
                        <div className="relative z-10 w-full flex flex-col items-center">
                            <h2 className="text-3xl font-bold text-slate-700 mb-8 bg-white/80 p-4 rounded-xl backdrop-blur-sm">
                                {gameType.id === 'scoreAttack' ? 'ã˜ã‹ã‚“ã‚’ãˆã‚‰ã‚“ã§ã­' : 'ã‚‚ã‚“ã ã„æ•°ã‚’ãˆã‚‰ã‚“ã§ã­'}
                            </h2>
                            <div className="grid grid-cols-2 gap-4 w-full max-w-md px-4">
                                {SETTINGS_OPTIONS[gameType.id].map((opt) => (
                                    <button key={opt.value} onClick={() => selectSetting(opt.value)} className="bg-white/90 border-b-4 border-slate-200 hover:border-indigo-400 hover:bg-indigo-50 p-6 rounded-2xl shadow-md transition-all text-xl font-black flex items-center justify-center backdrop-blur-sm">
                                        {opt.label}
                                    </button>
                                ))}
                            </div>
                            <button onClick={() => setMode(MODES.MENU)} className="mt-8 text-slate-500 font-bold hover:text-slate-700 flex items-center gap-2 bg-white/80 px-4 py-2 rounded-full"><IconRotateCcw size={20} /> ã‚‚ã©ã‚‹</button>
                        </div>
                    </div>
                );
            }

            if (mode === MODES.DIFFICULTY) {
                return (
                    <div className="min-h-screen bg-indigo-50 flex flex-col items-center justify-center p-4 font-sans relative z-0">
                         <BackgroundAnimation />
                         <div className="relative z-10 w-full flex flex-col items-center">
                            <h2 className="text-3xl font-bold text-slate-700 mb-8 bg-white/80 p-4 rounded-xl backdrop-blur-sm">ãªã‚“ã„ã©ã‚’ãˆã‚‰ã‚“ã§ã­</h2>
                            <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 w-full max-w-2xl px-4">
                                {Object.values(DIFFICULTIES).map((diff) => (
                                    <button key={diff.id} onClick={() => selectDifficulty(diff)} className={`${diff.color} border-b-4 p-6 rounded-2xl shadow-md hover:brightness-95 active:scale-95 transition-all flex flex-col items-center justify-center gap-2 h-32 bg-opacity-90 backdrop-blur-sm`}>
                                        <span className="text-2xl font-black">{diff.label}</span>
                                        <span className="text-sm opacity-75 font-bold bg-white/40 px-3 py-1 rounded-full">{diff.symbols}ã¤ã® ãˆ</span>
                                    </button>
                                ))}
                            </div>
                            <button onClick={() => {
                                if (gameType.id === 'practice') setMode(MODES.MENU);
                                else setMode(MODES.SETTINGS);
                            }} className="mt-8 text-slate-500 font-bold hover:text-slate-700 flex items-center gap-2 bg-white/80 px-4 py-2 rounded-full"><IconRotateCcw size={20} /> ã‚‚ã©ã‚‹</button>
                        </div>
                    </div>
                );
            }

            if (mode === MODES.GAME) {
                return (
                    <div className="min-h-screen bg-sky-100 flex flex-col items-center font-sans overflow-hidden select-none">
                        <div className="w-full bg-white p-2 sm:p-4 shadow-sm flex items-center justify-between px-4 z-10 shrink-0">
                            <div className="flex items-center gap-2">
                                <div className={`p-2 rounded-lg ${gameType.id === 'scoreAttack' ? 'bg-orange-100 text-orange-600' : 'bg-blue-100 text-blue-600'}`}><IconClock size={24} className="w-5 h-5 sm:w-6 sm:h-6" /></div>
                                <div className="text-2xl sm:text-3xl font-black font-mono text-slate-700">{gameType.id === 'scoreAttack' ? formatTime(timeLeft) : formatTime(elapsedTime)}</div>
                            </div>
                            <div className="flex flex-col items-center px-2"><div className="text-[10px] sm:text-xs font-bold text-slate-400 tracking-widest text-center">{gameType.label}</div><div className="text-xs sm:text-sm font-bold text-slate-300">{difficulty.label}</div></div>
                            <div className="flex items-center gap-2">
                                <div className="text-2xl sm:text-3xl font-black font-mono text-slate-700">{score}</div>
                                <div className="p-2 rounded-lg bg-yellow-100 text-yellow-600">
                                    {gameType.id === 'timeAttack' ? <span className="font-black text-lg">/ {gameSetting}</span> : <IconStar size={24} className="w-5 h-5 sm:w-6 sm:h-6" fill="currentColor" />}
                                </div>
                            </div>
                        </div>
                        <div className="flex-1 flex flex-col md:flex-row items-center justify-center gap-8 md:gap-16 w-full max-w-4xl p-4 relative">
                            <div className="absolute top-4 text-slate-500 font-bold text-lg opacity-50 pointer-events-none whitespace-nowrap">åŒã˜çµµæŸ„ã‚’ã‚¿ãƒƒãƒï¼</div>
                            <Card symbols={cards.left} onSymbolClick={handleSymbolClick} disabled={!!matchFound} isWrong={isWrong} />
                            <Card symbols={cards.right} onSymbolClick={handleSymbolClick} disabled={!!matchFound} isWrong={isWrong} />
                            {matchFound && <div className="absolute inset-0 z-20 flex items-center justify-center pointer-events-none"><div className="text-9xl animate-bounce drop-shadow-2xl">â­•</div></div>}
                            
                            {/* Penalty Message */}
                            {penaltyMessage && (
                                <div className="absolute inset-0 z-30 flex items-center justify-center pointer-events-none">
                                    <div className="text-4xl font-black text-red-500 bg-white/80 px-4 py-2 rounded-xl animate-float-up drop-shadow-lg">
                                        {penaltyMessage}
                                    </div>
                                </div>
                            )}

                        </div>
                        <div className="shrink-0 p-2 text-center z-10 mb-4"><button onClick={() => setMode(MODES.MENU)} className="text-slate-400 font-bold hover:text-slate-600 inline-flex items-center gap-2 py-2">ã‚„ã‚ã‚‹</button></div>
                    </div>
                );
            }

            if (mode === MODES.RESULT) {
                return (
                    <div className="min-h-screen bg-yellow-50 flex flex-col items-center justify-center p-4 font-sans text-slate-800 relative z-0">
                        <BackgroundAnimation />
                        <div className="relative z-10 bg-white p-8 rounded-3xl shadow-xl w-full max-w-md text-center border-b-8 border-yellow-200 relative overflow-hidden">
                            {isNewRecord && (
                                <div className="absolute top-0 left-0 w-full bg-orange-400 text-white font-black py-1 text-sm animate-pulse">
                                    è‡ªå·±ãƒ™ã‚¹ãƒˆæ›´æ–°ï¼
                                </div>
                            )}
                            <div className="flex justify-center mb-6 text-yellow-500">
                                {isNewRecord ? <div className="animate-pop"><IconCrown size={80} fill="#facc15" className="text-orange-500" /></div> : <IconTrophy size={64} fill="currentColor" />}
                            </div>
                            <h2 className="text-4xl font-black mb-2 text-slate-700">ãŠã—ã¾ã„ï¼</h2>
                            <p className="text-slate-400 font-bold mb-1">{gameType.label} - {difficulty.label}</p>
                            {gameType.id !== 'practice' && (
                                <p className="text-slate-400 font-bold mb-6 text-sm">
                                    ({gameType.id === 'scoreAttack' ? `${formatTime(gameSetting)}` : `${gameSetting}ã‚‚ã‚“`})
                                </p>
                            )}
                            
                            <div className="grid grid-cols-2 gap-4 mb-6">
                                <div className={`p-4 rounded-xl ${gameType.id === 'scoreAttack' ? 'bg-indigo-50 border-2 border-indigo-100' : 'bg-slate-50'}`}>
                                    <div className="text-slate-400 text-xs font-bold mb-1">ã‚¹ã‚³ã‚¢</div><div className="text-3xl font-black text-slate-700">{score} <span className="text-sm">ã“</span></div>
                                </div>
                                <div className={`p-4 rounded-xl ${gameType.id === 'timeAttack' ? 'bg-indigo-50 border-2 border-indigo-100' : 'bg-slate-50'}`}>
                                    <div className="text-slate-400 text-xs font-bold mb-1">ã˜ã‹ã‚“</div><div className="text-3xl font-black text-slate-700">{formatTime(elapsedTime)}</div>
                                </div>
                            </div>
                            
                            {gameType.id !== 'practice' && (
                                <div className="mb-8 bg-yellow-50 p-3 rounded-lg border border-yellow-100">
                                    <div className="text-yellow-600 text-xs font-bold">ã“ã‚Œã¾ã§ã®ãƒ™ã‚¹ãƒˆ</div>
                                    <div className="text-xl font-black text-yellow-700">{getRecordDisplay()}</div>
                                </div>
                            )}

                            {gameType.id === 'timeAttack' && score < gameSetting && <div className="mb-6 p-3 bg-red-100 text-red-600 rounded-lg font-bold">ã˜ã‹ã‚“ãã‚Œ... ãŠã—ã„ï¼</div>}
                            
                            <div className="space-y-3">
                                <button onClick={() => startGame(gameType, gameSetting, difficulty)} className="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-4 rounded-xl shadow-lg border-b-4 border-indigo-700 active:border-b-0 active:translate-y-1 transition-all flex items-center justify-center gap-2"><IconRotateCcw size={20} /> ã‚‚ã†ã„ã¡ã©ã‚„ã‚‹</button>
                                <button onClick={() => setMode(MODES.MENU)} className="w-full bg-white hover:bg-slate-50 text-slate-500 font-bold py-4 rounded-xl border-2 border-slate-200 flex items-center justify-center gap-2 transition-colors"><IconHome size={20} /> ã‚¿ã‚¤ãƒˆãƒ«ã¸</button>
                            </div>
                        </div>
                    </div>
                );
            }
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>